// API endpoints
const API_URL = {
  recommendations: '/api/properties/recommend',
  feedback: '/api/feedback/submit',
  stats: '/api/feedback/stats',
  retrain: '/api/feedback/retrain',
  export: '/api/feedback/export'
};

// Current state
let currentSubjectProperty = null;
let currentRecommendations = [];

// DOM Elements
document.addEventListener('DOMContentLoaded', function() {
  // Initialize UI elements and event listeners
  initializeUI();
});

function initializeUI() {
  // Set up form submission
  const propertyForm = document.getElementById('property-form');
  if (propertyForm) {
    propertyForm.addEventListener('submit', handlePropertyFormSubmit);
  }

  // Set up tab navigation if on dashboard page
  const tabButtons = document.querySelectorAll('.tab-btn');
  if (tabButtons.length > 0) {
    initializeTabs(tabButtons);
  }

  // Initialize feedback buttons
  const approveButton = document.getElementById('approve-button');
  const rejectButton = document.getElementById('reject-button');

  if (approveButton) {
    approveButton.addEventListener('click', () => handleFeedback(true));
  }

  if (rejectButton) {
    rejectButton.addEventListener('click', () => handleFeedback(false));
  }

  // Initialize dashboard if on dashboard page
  if (document.getElementById('dashboard')) {
    loadDashboardStats();
  }
}

function initializeTabs(tabButtons) {
  tabButtons.forEach(button => {
    button.addEventListener('click', () => {
      const target = button.dataset.target;
      
      // Deactivate all tabs
      document.querySelectorAll('.tab-btn').forEach(btn => {
        btn.classList.remove('active');
      });
      
      document.querySelectorAll('.tab-content').forEach(content => {
        content.classList.remove('active');
      });
      
      // Activate selected tab
      button.classList.add('active');
      document.getElementById(target).classList.add('active');
    });
  });
}

async function handlePropertyFormSubmit(e) {
  e.preventDefault();
  
  // Show loading state
  showLoader(true);
  
  // Get form data
  const formData = new FormData(e.target);
  const propertyData = {};
  
  // Convert form data to JSON
  formData.forEach((value, key) => {
    propertyData[key] = value === '' ? null : isNaN(value) ? value : parseFloat(value);
  });
  
  // Optional: Add defaults or validations here
  
  try {
    // Get recommendations from API
    const response = await fetch(API_URL.recommendations, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        subject_property: propertyData,
        count: 3
      }),
    });
    
    const data = await response.json();
    
    if (!response.ok) {
      throw new Error(data.detail || 'Failed to get recommendations');
    }
    
    // Store the returned data
    currentSubjectProperty = data.subject_property;
    currentRecommendations = data.recommendations;
    
    // Display the results
    displaySubjectProperty(currentSubjectProperty);
    displayRecommendations(currentRecommendations);
    showFeedbackSection(true);
    
  } catch (error) {
    // Show error message
    showAlert(error.message, 'danger');
    console.error('Error:', error);
  } finally {
    // Hide loading state
    showLoader(false);
  }
}

async function handleFeedback(isApproved) {
  // Ensure we have subject property and recommendations
  if (!currentSubjectProperty || currentRecommendations.length === 0) {
    showAlert('No recommendations to provide feedback for', 'danger');
    return;
  }
  
  // Show loading state
  showLoader(true);
  
  // Get selected properties if not approved
  const selectedProperties = isApproved ? [] : getSelectedProperties();
  
  // Create feedback data
  const feedbackData = {
    subject_id: currentSubjectProperty.id || 'unknown_id',
    subject_data: currentSubjectProperty,
    recommended_properties: currentRecommendations,
    is_approved: isApproved,
    selected_properties: selectedProperties,
    comments: document.getElementById('feedback-comments')?.value || ''
  };
  
  try {
    // Submit feedback to API
    const response = await fetch(API_URL.feedback, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(feedbackData),
    });
    
    const data = await response.json();
    
    if (!response.ok) {
      throw new Error(data.detail || 'Failed to submit feedback');
    }
    
    // Show success message
    showAlert(
      `Feedback submitted successfully! (${data.new_feedback_count}/${data.retrain_threshold} feedbacks until retraining)`,
      'success'
    );
    
    // Reset the form after successful feedback
    resetPropertyForm();
    
  } catch (error) {
    // Show error message
    showAlert(error.message, 'danger');
    console.error('Error:', error);
  } finally {
    // Hide loading state
    showLoader(false);
  }
}

function getSelectedProperties() {
  // Get manually selected properties from UI
  // This would depend on your UI implementation
  const selectedIds = Array.from(
    document.querySelectorAll('.property-card.selected')
  ).map(card => card.dataset.id);
  
  // Return selected properties from all properties
  return currentRecommendations.filter(prop => selectedIds.includes(prop.id));
}

function displaySubjectProperty(property) {
  const container = document.getElementById('subject-property-container');
  
  if (!container) return;
  
  container.innerHTML = '';
  
  const propertyCard = createPropertyCard(property, 'subject-property');
  container.appendChild(propertyCard);
}

function displayRecommendations(recommendations) {
  const container = document.getElementById('recommendation-container');
  
  if (!container) return;
  
  container.innerHTML = '';
  
  if (recommendations.length === 0) {
    container.innerHTML = '<p>No recommendations found for this property.</p>';
    return;
  }
  
  recommendations.forEach(property => {
    const propertyCard = createPropertyCard(property, 'recommendation-property');
    container.appendChild(propertyCard);
  });
}

function createPropertyCard(property, cardClass = '') {
  const card = document.createElement('div');
  card.className = `property-card ${cardClass}`;
  card.dataset.id = property.id || '';
  
  // Property image placeholder
  const imageUrl = property.photo_url || 
    'https://images.unsplash.com/photo-1580587771525-78b9dba3b914?w=800';
  
  // Format price if available
  const price = property.sale_price 
    ? `$${Number(property.sale_price).toLocaleString()}`
    : 'Price not available';
  
  card.innerHTML = `
    <div class="property-image" style="background-image: url('${imageUrl}')"></div>
    <div class="property-details">
      <div class="property-price">${price}</div>
      <div class="property-address">${property.address || 'Address not available'}</div>
      <div class="property-features">
        <span class="property-feature">${property.bedrooms || '?'} Beds</span>
        <span class="property-feature">${property.full_baths || '0'}.${property.half_baths || '0'} Baths</span>
        <span class="property-feature">${property.gla ? Math.round(property.gla) : '?'} sqft</span>
      </div>
      <div class="property-features">
        <span class="property-feature">Type: ${property.structure_type || 'Not specified'}</span>
        <span class="property-feature">Age: ${property.age || '?'} yrs</span>
      </div>
      <div class="property-actions">
        ${cardClass !== 'subject-property' ? `
          <button class="btn btn-primary select-property-btn">Select</button>
        ` : ''}
      </div>
    </div>
  `;
  
  // Add event listener to select button
  const selectBtn = card.querySelector('.select-property-btn');
  if (selectBtn) {
    selectBtn.addEventListener('click', () => {
      card.classList.toggle('selected');
      selectBtn.textContent = card.classList.contains('selected') ? 'Unselect' : 'Select';
    });
  }
  
  return card;
}

async function loadDashboardStats() {
  try {
    showLoader(true);
    
    // Fetch feedback statistics
    const response = await fetch(API_URL.stats);
    const stats = await response.json();
    
    if (!response.ok) {
      throw new Error(stats.detail || 'Failed to load statistics');
    }
    
    // Display statistics
    displayDashboardStats(stats);
    
  } catch (error) {
    showAlert(error.message, 'danger');
    console.error('Error:', error);
  } finally {
    showLoader(false);
  }
}

function displayDashboardStats(stats) {
  // Update stats cards
  document.getElementById('total-feedback-count').textContent = stats.total_count;
  document.getElementById('positive-feedback-count').textContent = stats.positive_count;
  document.getElementById('negative-feedback-count').textContent = stats.negative_count;
  document.getElementById('approval-rate').textContent = `${Math.round(stats.approval_rate * 100)}%`;
  
  // Update last updated timestamp
  if (stats.last_updated) {
    const lastUpdated = new Date(stats.last_updated);
    document.getElementById('last-updated-time').textContent = lastUpdated.toLocaleString();
  }
  
  // Update last retraining timestamp
  if (stats.last_retrain) {
    const lastRetrain = new Date(stats.last_retrain);
    document.getElementById('last-retrain-time').textContent = lastRetrain.toLocaleString();
  } else {
    document.getElementById('last-retrain-time').textContent = 'Never';
  }
}

async function handleRetrainModel() {
  try {
    showLoader(true);
    
    // Request model retraining
    const response = await fetch(API_URL.retrain, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        force: true
      }),
    });
    
    const result = await response.json();
    
    if (!response.ok) {
      throw new Error(result.detail || 'Failed to retrain model');
    }
    
    // Show success message
    showAlert(
      result.status === 'success' 
        ? 'Model retrained successfully!' 
        : result.reason || 'Retraining skipped',
      result.status === 'success' ? 'success' : 'info'
    );
    
    // Reload stats after retraining
    loadDashboardStats();
    
  } catch (error) {
    showAlert(error.message, 'danger');
    console.error('Error:', error);
  } finally {
    showLoader(false);
  }
}

async function handleExportFeedback() {
  try {
    showLoader(true);
    
    // Request feedback export
    const response = await fetch(API_URL.export);
    const result = await response.json();
    
    if (!response.ok) {
      throw new Error(result.detail || 'Failed to export feedback');
    }
    
    // Show success message
    showAlert(`Feedback data exported to ${result.path}`, 'success');
    
  } catch (error) {
    showAlert(error.message, 'danger');
    console.error('Error:', error);
  } finally {
    showLoader(false);
  }
}

function showFeedbackSection(show) {
  const feedbackSection = document.getElementById('feedback-section');
  if (feedbackSection) {
    feedbackSection.style.display = show ? 'block' : 'none';
  }
}

function showLoader(show) {
  const loader = document.getElementById('loader');
  if (loader) {
    loader.style.display = show ? 'block' : 'none';
  }
}

function showAlert(message, type) {
  const alertContainer = document.getElementById('alert-container');
  
  if (!alertContainer) return;
  
  // Create alert element
  const alert = document.createElement('div');
  alert.className = `alert alert-${type}`;
  alert.textContent = message;
  
  // Add close button
  const closeButton = document.createElement('button');
  closeButton.innerHTML = '&times;';
  closeButton.style.float = 'right';
  closeButton.style.border = 'none';
  closeButton.style.background = 'transparent';
  closeButton.style.fontSize = '20px';
  closeButton.style.marginLeft = '15px';
  closeButton.style.cursor = 'pointer';
  closeButton.onclick = () => alert.remove();
  
  alert.prepend(closeButton);
  
  // Add to container
  alertContainer.prepend(alert);
  
  // Auto-remove after 5 seconds
  setTimeout(() => {
    alert.remove();
  }, 5000);
}

function resetPropertyForm() {
  const form = document.getElementById('property-form');
  if (form) {
    form.reset();
  }
  
  // Clear current data
  currentSubjectProperty = null;
  currentRecommendations = [];
  
  // Clear displayed properties
  document.getElementById('subject-property-container')?.innerHTML = '';
  document.getElementById('recommendation-container')?.innerHTML = '';
  
  // Hide feedback section
  showFeedbackSection(false);
}

// Export functions for use in other scripts
window.app = {
  handleRetrainModel,
  handleExportFeedback,
  resetPropertyForm
}; 